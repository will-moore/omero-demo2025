<!--
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->

<!DOCTYPE html>
<html>
  <head>
    <title>OMERO tracker</title>

    <style>
      body {
        margin: 0;
        padding: 0;
      }
      p {
        margin: 0;
      }
      #scroll_frame {
        width: 100%;
        height: 100vh;
        overflow: scroll;
        padding: 0;
        margin: 0;
        inset: 0;
        background: #ddd;
      }
      .overlay {
        position: fixed;
        top: 10px;
        left: 10px;
        background-color: rgba(255, 255, 255, 0.8);
        padding: 5px;
        border: 1px solid #000;
        z-index: 1000;
      }
      canvas {
        background: white;
      }
      .pan {
        font-size: 40px;
        margin: 0;
        padding: 0;
        line-height: 15px;
      }
    </style>
  </head>

  <body>
    <div id="scroll_frame">
      <canvas
        id="trackerCanvas"
        width="{{ width }}"
        height="{{ height }}"
        style="border: 1px solid #000000"
      ></canvas>
    </div>

    <div class="overlay">
      <!-- <p>Tracking image: {{ name }} (ID: {{ imageId }})</p> -->
      <button onclick="zoomCanvasToFit();">Zoom to fit</button>
      Zoom: <span id="zoom">100</span>
      <button onclick="zoomIn();">+</button>
      <button onclick="zoomOut();">-</button>
      Pan:
      <button class="pan" onclick="pan('left');" style="transform: rotate(180deg);">&#8227;</button>
      <button class="pan" onclick="pan('right');">&#8227;</button>
      <button class="pan" onclick="pan('up');" style="transform: rotate(270deg);">&#8227;</button>
      <button class="pan" onclick="pan('down');" style="transform: rotate(90deg);">&#8227;</button>
    </div>

    <script>
      // Browser has canvas size limit: https://jhildenbiddle.github.io/canvas-size/#/
      const CANVAS_MAX_SIZE = 10000;

      // find max width and height from context
      const imgWidth = {{ width }};
      const imgHeight = {{ height }};
      const imageId = {{ imageId }};
      // Keep track of current position (last known center from iviewer)
      let currentExtent = null;

      const longestSide = Math.max(imgWidth, imgHeight);
      const canvasScale = (longestSide > CANVAS_MAX_SIZE) ? CANVAS_MAX_SIZE / longestSide : 1.0;

      // scale of the canvas within the scroll frame
      let scale = 1;

      const canvas = document.getElementById("trackerCanvas");
      canvas.width = imgWidth * canvasScale;
      canvas.height = imgHeight * canvasScale;
      const ctx = canvas.getContext("2d");

      function updateZoomDisplay() {
        document.getElementById("zoom").innerText = (scale * 100).toFixed(0) + "%";
      }

      // Resize the canvas with css to fit the scroll frame
      const scrollFrame = document.getElementById("scroll_frame");
      function zoomCanvasToFit() {
        const frameWidth = scrollFrame.clientWidth;
        const frameHeight = scrollFrame.clientHeight;
        if (imgWidth / imgHeight > frameWidth / frameHeight) {
          // fit to width
          scale = frameWidth / imgWidth;
          canvas.style.width = frameWidth + "px";
          canvas.style.height = imgHeight * scale + "px";
        } else {
          // fit to height
          scale = frameHeight / imgHeight;
          canvas.style.width = imgWidth * scale + "px";
          canvas.style.height = frameHeight + "px";
        }
        updateZoomDisplay();
      }

      function updateScale() {
        // Find the centre before scaling...
        let centerX = (scrollFrame.scrollLeft + scrollFrame.clientWidth / 2) / canvas.clientWidth;
        let centerY = (scrollFrame.scrollTop + scrollFrame.clientHeight / 2) / canvas.clientHeight;
        // ...then scale the canvas
        canvas.style.width = imgWidth * scale + "px";
        canvas.style.height = imgHeight * scale + "px";
        // ...and scroll to keep the same centre
        let scrollX = centerX * canvas.clientWidth - scrollFrame.clientWidth / 2;
        let scrollY = centerY * canvas.clientHeight - scrollFrame.clientHeight / 2;
        scrollFrame.scrollTo(scrollX, scrollY);
        // Update zoom display
        updateZoomDisplay();
      }

      function zoomIn() {
        scale *= 2;
        updateScale();
      }
      function zoomOut() {
        scale /= 2;
        updateScale();
      }

      // Initial zoom to fit
      zoomCanvasToFit();

      const bc = new BroadcastChannel('viewer.pan');
      bc.onmessage = function (event) {
        const data = event.data;
        console.log('Received data:', data);
        if (data.imageId === imageId) {
          let ext = data.extent;
          let x = ext.minX * canvasScale;
          let y = ext.minY * canvasScale;
          let width = (ext.maxX - ext.minX) * canvasScale;
          let height = (ext.minY - ext.maxY) * canvasScale;
          // update last known center
          currentExtent = {...ext};

          // use iviewer viewport width to calculate zoom
          let viewportWidth = data.size[0];
          let viewportZoom = viewportWidth / (ext.maxX - ext.minX);
          let opacity = 0.5 * viewportZoom;
          console.log(`opacity ${opacity}`, x, y, width, height);
          ctx.fillStyle = `rgba(255, 0, 0, ${opacity})`;
          ctx.fillRect(x, y, width, height);

          // scroll the frame to show the rectangle in the center
          // get current width of canvas in scroll frame
          let canvasWidth = canvas.clientWidth;
          let canvasHeight = canvas.clientHeight;
          // relative position of rectangle center
          let posX = ext.minX / imgWidth;
          let posY = ext.minY / imgHeight;
          // position in canvas
          let canvasPosX = (posX * canvasWidth) - scrollFrame.clientWidth / 2;
          let canvasPosY = (posY * canvasHeight) - scrollFrame.clientHeight / 2;
          console.log(`canvasPos ${canvasPosX}, ${canvasPosY}`);
          scrollFrame.scrollTo(canvasPosX, canvasPosY);
        }
      };


      const bc_in = new BroadcastChannel('request.viewer.pan');

      function pan(direction) {
        console.log("Current extent:", currentExtent);
        let extWidth = currentExtent.maxX - currentExtent.minX;
        let extHeight = currentExtent.maxY - currentExtent.minY;
        console.log("extWidth", extWidth);
        let cx = currentExtent.minX + (extWidth / 2);
        let cy = currentExtent.minY + (extHeight / 2);
        if (direction === 'left') {
          cx -= extWidth;
        } else if (direction === 'right') {
          cx += extWidth;
        } else if (direction === 'up') {
          cy += extHeight;
        } else if (direction === 'down') {
          cy -= extHeight;
        }
        console.log("Pan right requested", cx + extWidth, cy);
        bc_in.postMessage({
          imageId: imageId,
          center: { x: cx, y: cy }
        });
      }

      document.querySelector("body").onkeyup = function (e) {
        e.preventDefault();
        if (e.key === "ArrowLeft") {
          pan('left');
        } else if (e.key === "ArrowRight") {
          pan('right');
        } else if (e.key === "ArrowUp") {
          pan('up');
        } else if (e.key === "ArrowDown") {
          pan('down');
        }
      };
    </script>
  </body>
</html>
